<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://putawande.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://putawande.github.io/" rel="alternate" type="text/html" /><updated>2025-11-28T11:35:04+00:00</updated><id>https://putawande.github.io/feed.xml</id><title type="html">Tanadol Deachprapakorn</title><subtitle>Tanadol Deachprapakorn&apos;s personal website</subtitle><entry><title type="html">React New Activity Component — Hides Components Without Losing States</title><link href="https://putawande.github.io/react-new-activity-component-hides-components-without-losing-states" rel="alternate" type="text/html" title="React New Activity Component — Hides Components Without Losing States" /><published>2025-11-23T00:00:00+00:00</published><updated>2025-11-23T00:00:00+00:00</updated><id>https://putawande.github.io/react-new-activity-component-hides-components-without-losing-states</id><content type="html" xml:base="https://putawande.github.io/react-new-activity-component-hides-components-without-losing-states"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Usually, when we want to hide our components in React we use conditional rendering, or css <code class="language-plaintext highlighter-rouge">display: none</code>. If we use conditional rendering, the states will be lost when it is hidden because the component will unmount. React 18 introduces <code class="language-plaintext highlighter-rouge">&lt;Activity&gt;</code> component, a new feature designed to manage the visibility, especially for elements that are frequently toggled.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">visible</span><span class="p">,</span> <span class="nx">setVisible</span><span class="p">]</span> <span class="o">=</span> <span class="nf">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

  <span class="k">return </span><span class="p">(</span>
    <span class="p">{</span><span class="cm">/* Conditional Rendering*/</span><span class="p">}</span>
    <span class="p">{</span><span class="nx">visible</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Content<span class="p">&lt;/&gt;}</span>
    <span class="p">{</span><span class="cm">/* or CSS Styling */</span><span class="p">}</span>
    <span class="p">&lt;</span><span class="nt">p</span> <span class="na">style</span><span class="p">=</span><span class="si">{</span><span class="p">{</span><span class="na">display</span><span class="p">:</span> <span class="nx">visible</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">block</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span><span class="p">}</span><span class="si">}</span><span class="p">&gt;</span>
      Content
    <span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="how-it-works">How It Works?</h2>

<p>The <code class="language-plaintext highlighter-rouge">&lt;Activity&gt;</code> component allows you to manage the visibility of its children by using the <code class="language-plaintext highlighter-rouge">mode</code> prop.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">Activity</span> <span class="na">mode</span><span class="p">=</span><span class="si">{</span><span class="nx">isShowingSidebar</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">visible</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">hidden</span><span class="dl">'</span><span class="si">}</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">Sidebar</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nc">Activity</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>In my opinion, this is cleaner than conditional rendering, or conditional CSS styling.</p>

<ul>
  <li>When <code class="language-plaintext highlighter-rouge">mode='hidden'</code>, React hides the component by applying <code class="language-plaintext highlighter-rouge">display: "none"</code> on CSS.</li>
  <li>It will also destroys their Effects and clean up any subscriptions.</li>
  <li>But the children will still re-render at a lower priority, if there are new props.</li>
  <li>When the mode changes to visible again, React will re-create the Effects and restore their previous states.</li>
</ul>

<h2 id="benefits">Benefits</h2>

<h3 id="state-preservation">State Preservation</h3>

<p>If we use conditional rendering, the state is lost when the component unmounts. We can fix this by moving the state to the parent component. But this breaks encapsulation. It would be better if the state is kept inside the component. The new <code class="language-plaintext highlighter-rouge">&lt;Activity&gt;</code> component enables us to do this.</p>

<h3 id="dom-state-preservation">DOM State Preservation</h3>

<p>Because React applies <code class="language-plaintext highlighter-rouge">display: "none"</code> on CSS, the state of the DOM is preserved. Example, the user’s input is not lost when the component unmounts.</p>

<h3 id="pre-rendering-content">Pre-Rendering Content</h3>

<p>The content that will become visible later, is pre-rendered. Because React renders the children at a lower priority when the mode is hidden.</p>

<h3 id="speeding-up-page-interaction-on-load-for-ssr">Speeding Up Page Interaction On Load for SSR</h3>

<p>React uses Selective Hydration under-the-hood. It works by hydrating your app’s HTML in chunks, allowing early interactions on some components even-though your whole code is not yet finished loading.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Tab</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">HeavyComponent</span><span class="dl">'</span>

<span class="kd">function</span> <span class="nf">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">setSelected</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="nx">Tab</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span><span class="p">)</span>

  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="s">'tab-menu'</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">setSelected</span><span class="p">(</span><span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
          Home
        <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">setSelected</span><span class="p">(</span><span class="dl">'</span><span class="s1">HeavyComponent</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
          HeavyComponent
        <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

      <span class="si">{</span><span class="nx">selected</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nc">Home</span> <span class="p">/&gt;</span><span class="si">}</span>
      <span class="si">{</span><span class="nx">selected</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">HeavyComponent</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nc">HeavyComponent</span> <span class="p">/&gt;</span><span class="si">}</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span>
</code></pre></div></div>

<p>If we use conditional rendering, React doesn’t utilize Selective Hydration to separate our components into different chunks. It must hydrate the whole page which could lead to unresponsive tab buttons.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Tab</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">HeavyComponent</span><span class="dl">'</span>

<span class="kd">function</span> <span class="nf">Page</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">setSelected</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="nx">Tab</span><span class="o">&gt;</span><span class="p">(</span><span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span><span class="p">)</span>

  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="s">'tab-menu'</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">setSelected</span><span class="p">(</span><span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
          Home
        <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">setSelected</span><span class="p">(</span><span class="dl">'</span><span class="s1">HeavyComponent</span><span class="dl">'</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
          HeavyComponent
        <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

      <span class="p">&lt;</span><span class="nc">Activity</span> <span class="na">mode</span><span class="p">=</span><span class="si">{</span><span class="nx">selected</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Home</span><span class="dl">'</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">visible</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">hidden</span><span class="dl">'</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Home</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Activity</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Activity</span> <span class="na">mode</span><span class="p">=</span><span class="si">{</span><span class="nx">selected</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">HeavyComponent</span><span class="dl">'</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">visible</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">hidden</span><span class="dl">'</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">HeavyComponent</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Activity</span><span class="p">&gt;</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span>
</code></pre></div></div>

<p>This way React can separately hydrate tab menu, home and heavy component. The tab menu could be interactable first before the heavy component finishes loading.</p>

<h2 id="demo">Demo</h2>

<iframe src="https://codesandbox.io/p/github/PutawanDE/react-activity-demo/main?import=true&amp;embed=1&amp;file=%2Fsrc%2FApp.tsx" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>

<h2 id="when-not-to-use">When Not to Use</h2>

<ul>
  <li><strong>Permanent removal:</strong> This is obvious. If we want to remove it completely why should it linger in memory?</li>
  <li><strong>When the component changes frequently and performance is critical:</strong> Although it re-renders at a lower priority, it still consumes resources.</li>
  <li><strong>When the component’s effect should always run when visible, regardless of previous state:</strong> If you want to run the effects from a “fresh” state, you might prefer a full unmount and remount.</li>
</ul>

<h2 id="references-and-further-readings">References and Further Readings</h2>

<ul>
  <li><a href="https://react.dev/reference/react/Activity">Activity Api Reference - React</a></li>
</ul>]]></content><author><name></name></author><category term="Web Development" /><category term="React" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">I Tried Out Flutter’s New Rendering Engine: Impeller</title><link href="https://putawande.github.io/i-tried-out-flutters-new-rendering-engine-impeller" rel="alternate" type="text/html" title="I Tried Out Flutter’s New Rendering Engine: Impeller" /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>https://putawande.github.io/i-tried-out-flutters-new-rendering-engine-impeller</id><content type="html" xml:base="https://putawande.github.io/i-tried-out-flutters-new-rendering-engine-impeller"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Flutter, Google’s open-source UI software development kit, has been making waves in the mobile development community. Recently, I had the opportunity to explore Flutter’s new rendering engine, Impeller. In this post, I’ll share my experience and insights on how Impeller enhances Flutter’s performance and graphics capabilities.</p>

<h2 id="background">Background</h2>

<p>Before Impeller, Flutter relied on the Skia graphics library for rendering. Skia performed well overall but had limitations, especially with complex animations and high-performance graphics. At one point, I experimented with custom GLSL shaders inside Flutter — and ran into a problem: shader compilation.</p>

<p>A shader is a tiny program that runs on your GPU and decides how each pixel should look. Like any program, it must be compiled before execution. The tricky part is that GPUs vary widely in architecture and supported instructions. For example, gamers may know that features like DLSS exist on NVIDIA hardware but not on AMD. To handle this variety, many GPU drivers compile shaders on demand at runtime.</p>

<p>That’s why, when you launch a new game for the first time, it often loads for a while before gameplay begins — the GPU is compiling shaders in the background. Flutter’s rendering pipeline worked in a similar way. The first time you navigate to a new screen or trigger a new animation, you might notice stutters or dropped frames, known as animation jank.</p>

<p>Enter Impeller. Impeller solves this problem by using precompiled sets of shaders — compiled offline ahead of runtime — and is built to leverage modern graphics APIs such as Metal on iOS and Vulkan on Android (falling back to OpenGL ES on older devices). Previously, Flutter’s Skia backend used Metal on iOS and OpenGL ES on Android. Impeller’s build-time shader compiler converts GLSL into a GPU-specific intermediate representation, ensuring shaders can load instantly without per-frame compilation.</p>

<p align="center">
<img src="/assets/img/i-tried-out-flutters-new-rendering-engine-impeller/what_is_vulkan_compared_to_gl.png" alt="What is Vulkan compared to OpenGL?" />
<em>Figure 1: Vulkan vs. OpenGL <a href="https://docs.vulkan.org/guide/latest/what_is_vulkan.html">source</a></em>
</p>

<h2 id="trying-out-impeller">Trying Out Impeller</h2>

<h3 id="performance">Performance</h3>

<p>I used Flutter version 3.35.0. In this version, Impeller is enabled by default on iOS, and on Android it runs when Vulkan is available. I tested Impeller on a Vulkan-supported Android device to observe noticeable performance differences. I ran the app in profile mode to collect accurate frame-time data using Flutter DevTools.</p>

<p align="center">
<img src="/assets/img/i-tried-out-flutters-new-rendering-engine-impeller/shader-compilation-frames-chart.png" alt="Shader Compilation Frames Chart" />
<em>Figure 2: Profiling chart showing shader compilation time in dark red color <a href="https://docs.flutter.dev/tools/devtools/performance">source</a></em>
</p>

<p>I noticed immediately that Skia spent a lot of frame time compiling shaders when opening the splash screen, a bottom sheet, and a new screen. These compilation pauses caused animation jank during page transitions, which reduces the polish of the app. Impeller, on the other hand, produced smoother and more predictable frame rates, although the average FPS did not differ significantly between the two engines.</p>

<h3 id="anti-aliasing">Anti-Aliasing</h3>

<p>Impeller supports MSAA (Multisample Anti-Aliasing), a modern technique that smooths jagged edges along geometry in your UI. MSAA is more computationally expensive than the anti-aliasing previously used in Skia, but it produces higher-quality, smoother edges. Although more expensive, modern mobile devices can handle it without issues.</p>

<p>One particular issue that MSAA helps address is the thin gaps that can appear between two adjacent containers of the same color, caused by sub-pixel rounding errors in the UI. This improved anti-aliasing may help close those gaps, making the UI appear more polished and seamless.</p>

<p align="center">
<img src="/assets/img/i-tried-out-flutters-new-rendering-engine-impeller/thin-gap-problem.jpg" alt="Thin gap between two adjacent containers of the same color" class="max-w-72" />
<em>Figure 3: Thin gap between two adjacent containers of the same color <a href="https://github.com/flutter/flutter/issues/14288#issuecomment-1156754187">source</a></em>
</p>

<h3 id="text-rendering">Text Rendering</h3>

<p>I, along with others, have observed text jitter when over-scrolling lists on Android. A similar issue also occurred when scaling text in previous Flutter versions. According to discussions on GitHub, this may be caused by floating-point errors and sub-pixel alignment issues. Interestingly, this problem does not appear on Skia. You can see the issue <a href="https://github.com/flutter/flutter/issues/177492">here</a>.</p>

<h3 id="other-problems">Other Problems</h3>

<p>You can view open Impeller-related issues on <a href="https://github.com/flutter/flutter/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22e%3A%20impeller%22">Github</a>. Most of these issues are related to performance and rendering on Android devices, which can vary due to hardware, screen resolution, and driver differences. I believe the Flutter team is actively addressing these issues, and I look forward to the improvements. From my experience, Impeller has improved significantly since earlier versions, at least on my device.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Impeller is a promising rendering engine and a solid choice for modern devices. It is designed specifically for Flutter and leverages modern graphics APIs and hardware capabilities, such as MSAA, to improve rendering quality.</p>

<p>During my trial, Impeller delivered smoother and more predictable performance, and its improved anti-aliasing produces higher-quality visuals that may help address sub-pixel rendering issues. While there are still some performance and text-rendering issues on certain Android devices, the team is actively working on fixes. Since Impeller is still early in adoption, it is natural that there might be some bugs with edge cases.</p>

<h2 id="references-and-further-readings">References and Further Readings</h2>

<ul>
  <li><a href="https://github.com/flutter/flutter/issues/14288">Antialiasing behaviour when same-colour  #14288</a></li>
  <li><a href="https://youtu.be/vd5NqS01rlA?si=euMPrcZvlN8gAKVh">Introducing Impeller - Flutter’s new rendering engine</a></li>
  <li><a href="https://docs.flutter.dev/perf/impeller">Impeller rendering engine</a></li>
  <li><a href="https://docs.vulkan.org/guide/latest/what_is_vulkan.html">What is Vulkan?</a></li>
  <li><a href="https://docs.flutter.dev/tools/devtools/performance">Use the Performance view</a></li>
  <li><a href="https://github.com/flutter/flutter/issues/167795">[Android] Stretch overscroll causes text jitter when using Impeller #167795</a></li>
  <li><a href="https://github.com/flutter/flutter/issues/162949">[Impeller] Rendered Text Wiggles when scaling #162949</a></li>
  <li><a href="https://vr.arvilab.com/blog/anti-aliasing">The Meaning of Anti-Aliasing: FXAA, SMAA, MSAA, SSAA, TXAA Algorithms</a></li>
</ul>]]></content><author><name></name></author><category term="Flutter" /><category term="Computer Graphic" /><category term="Mobile Development" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>